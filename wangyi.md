##笔试
1、NXN矩阵表示工厂和人住的小区，1表示工厂，0表示小区。打印所有的距离工厂最远的地点，如果最远有多个，都打印坐标；如果都是工厂或者都是小区，就打印0
思路：就是统计工厂的坐标集合vector，小区坐标的集合
对于每一个小区坐标，与所有的工厂坐标求距离，选取其中的最小值（因为距离工厂的距离是所有工厂里面距离最近的）；
然后找这些小区对于的工厂距离中的最大值，并打印对应的坐标即可。（当时有一些用例没通过）
2、漂亮数
给出一个数组，求出来数组的子序列（不是连续子序列）中之和是6的倍数中的最大值，就是找所有序列和是6的倍数中的和的最大值

是一种0-1背包的问题延伸

用一个6长度的vector，位置i存放的值表示数字之和%6之后是i的这些和的最大值。
不妨换一种思路，我们把序列和%6的结果作为一种状态，那么我们可以知道序列增加一个或者减少一个元素就是在i=0-5这些状态上转移
我们从第一个数据输入开始维护vector，vector中表示状态为i就是之和%6等于i的序列和的最大值。
那么我们如果有数据来，我们就对所有的有序列达到过的状态都加上新的数据，去更新下一个状态的最大值
更新也有一些注意：就是每一轮数据先更新已有的状态，最后比较一下新数据temp%6对应的位置的最大值是否大于temp，如果小于temp就多更新一个这个状态
最后结束之后在0位置上的就是最大的6的倍数的子序列和。

3、优惠问题
就是给定T为额度，V为优惠，接着给一些商品价格的数组，不一定全部下单，就是找到一种组合使得所花的金额最少

4、三次回文数
就是一个数字是回文，并且是一个回文的三次方，那么这个数字就是就是三次回文数
给定范围，查找其中的三次回文数

我的理解就是从0开始计算，如果这个数字是回文，并且三次方在范围里面，就加1.
实现我觉得没有问题，但是输入是字符串，还要转换为整数
输出[1,2]这种，也不说输出的是啥，我现在才理解到是要放在一个数组中例如vector直接输出吧

问答题：
1、dynamic_cast和static_cast的区别已经应用场景？
补充后续理解：
static_cast:是静态强制类型转换，主要用于：1、非多态的父类和派生类类型之间的转换：上行就是父类转换为基类是安全的，下行就是基类转换为父类是不安全的，因为没有动态类型检查，所以是不安全的。
2、用于基本数据类型之间的转换，例如int和char之间的转换； 3、把空指针转换为任何目标类型的空指针；4、把任何类型的表达式转换为void类型。
interprte_cast：是用于不同类型指针和引用之间的转换，是通过比特复制的方式。也可以用于指针和整形类型之间的转换。
const_cast:主要用于去const属性的转换：将const的指针和引用转换为非const的；
dynamic_cast:用于基类指针引用和派生类指针和引用之间转换，对于下行转换是安全的，转换失败会返回NULL。如果基类的指针指向的是派生类对象那么可以转换成功，否则返回null。
关键是dynamic_cast是可以处理多态类型的。
2、内存对齐是什么？内存对齐的意义
内存对齐是将数据放在对齐的地址上，尽量不跨步存储。对于32位一般是4字节对齐，64位是8字节对齐。对于struct而言，要求第一个元素放在偏移量为0的地方，后面的数据放在基本类型宽度的整数倍的地方，
最后struct也是其中最大基本类型宽度的整数倍的大小。
因为机器一般是按照2、4、8字节这样的内存粒度来读取数据，对于粒度是8字节的，如果数据没有放在对齐的地方，需要多次读取再组合。并且有些机器对于非对齐的存取会发生异常或者不支持。
