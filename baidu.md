笔试主要分为两个部分，前面部分是选择题，包括单选和多选，一共20多道。主要涉及的是C++程序的判断、类的合法性、构造和析构执行顺序、Linux命令包括读写磁盘顺序等、数据库的操作以及操作系统
的相关知识。

编程题：
1、一群演员n个，有m个角色，角色有权值，每个演员有自己的期望值，依次找到每个演员可以选择的角色的个数，条件就是演员选择的角色的权值要**不小于**自己的期望值。
实现：主要是将角色数组存储下来，进行排序。然后利用二分法找到第一个大于等于自己的位置pos，返回值就是m-pos就是对于的个数。ac

2、n个运动员位于n个赛场，接下来有m个命令，输出这些命令的结果。
‘C’ a1 a2
这个命令表示要将a1位置的数字排到a2对于的位置后面去。
也就是那前面是相当于n个数组，将a1对应的数组中的数据放到a2对应的数组后面去，并且销毁掉a1对应的数组。
‘Q’ a1 a2
查询a1和a2是否在一个数组中，如果在就输出相邻的距离，否则输出-1.
实现：我经过思考有了一个思路，本质就是**并查集**。我的实现就是利用一个哈希表，键值key是n，后面的值对应的是一个pair<int,int,int>，分别表示对应的最近的父节点的值、在父节点的第几个、以自己为
父节点后面最大有几个。
编译没有通过。

后续实际上思路也是对的，只不过当时我是按照哈希表的方式，实际上定义全局数组即可，定义`fa[100010]`数组记录对应的那个运动员的父亲节点是谁。d数组记录自己到最近的父节点的距离。
只是需要注意的是，在进行find查找的时候要将数组d也进行更新，这样才好以一个基准记录运动员在一个数组下的距离。

3、两个字符串S和T，求S转换为T有多少种转换方式。转换只能按照：S=xy 转换成yx
这个我看别人的思路是动态规划。
思路就是先找出来有多少种组合方式可以由S转换为T，其实就是建立SS组合成一个字符串，然后T在SS上移动，看有多少种移动cnt下上匹配的。
然后就有了动态规划，初始值记录消耗i次转化的时候成功的次数，如果S==T就把初始成功的值设置为1，否则将失败值初始为1；
接下来`dp_success[i] = dp_success[i-1]*(cnt-1) + dp_failed[i-1]*(cnt));
dp_failed[i] = dp_success[i-1]*(len-cnt)+dp_failed[i-1]*(len-cnt-1)`
就是理解为有cnt个坑是我们要跳进去的，上一个跳成功，这一次跳成功只有cnt-1个选择，上一次失败这一次要成功有cnt个选择；失败的也是类似。
最后根据cnt是否为0决定返回`dp_success[len-1]`还是0；

这个思路确实不错，动态规划还是任重道远呀！
